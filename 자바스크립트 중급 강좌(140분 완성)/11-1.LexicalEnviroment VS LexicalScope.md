# Lexical 환경
스코프에 대해 공부할 때, 렉시컬 스코프를 공부했는데 렉시컬 스코프와 렉시컬 환경은 같은 의미를 갖는걸까? <br>
이전 내용을 복습하며 Lexical 환경에 대해 추가로 더 찾아보자.

<br>
<br>

## 🔥 [복습] 동적 스코프와 정적 스코프(렉시컬 스코프)
- 상위 스코프가 결정되는 기준은 아래와 같다
    1. **함수를 어디에서 호출**하였는지에 따라 상위 스코프를 결정
    2. **함수를 어디에서 선언**하였는지에 따라 상위 스코프를 결정
- 함수의 호출 위치에 따라 상위스코프를 결정하는 방식을 **동적 스코프(Dynamic Scope)** 라고 말한다
- 함수의 선언 위치에 따라 상위스코프를 결정하는 방식을 **정적 스코프(Static Scope)** 또는 **렉시컬 스코프(Lexical Scope)**라고 부른다
- 자바스크립트를 비롯한 **대부분의 프로그램 언어는 렉시컬 스코프를 따른다**

<br>

```javascript
var x = 1;

function first(){
	var x = 10;
	second();
}

function second(){
	console.log(x);
}

first();     // 1
second();    // 1
```

- 렉시컬 스코프를 따르는 자바스크립트에서는 함수를 선언한 시점에서 상위 스코프가 결정된다
- 어디에서 호출되었는지는 상위 스코프의 결정에 아무런 영향을 주지 않는다
- 위의 코드에서 `second()` 는 전역 스코프(Global Scope)에 선언되었다
- 그렇기때문에 `second()` 의 상위 스코프는 **전역스코프(Global Scope) 이다**
- 정리하면, 함수 first()의 스코프(function level scope)에서 
  - x에 해당하는 값을 찾을 수 없어, 
  - 스코프 체인에 의해 상위 스코프로 향했고, 
   - 상위 스코프인 전역 스코프의 x 값을 가져와 출력한 것이다

<br>
<br>

## 🔥 [추가] Lexical 환경
- 자바스크립트에서 실행중인 함수와 코드블록 등 스크립트의 전체는 렉시컬 환경이라 불리는 **내부 숨김 연관 객체**를 갖는다
- 렉시컬 환경 객체는 아래의 두 부분으로 구성된다
    1. 환경 레코드 : 모든 지역 변수를 프로퍼티로 저장하고 있는 객체
        - 모든 지역변수를 프로퍼티로 저장하고 있는 객체
        - this값과 같은 기타 정보도 저장한다
        - 변수는 특수 내부 객체인 환경 레코드의 프로퍼티일 뿐이다
        - 변수를 가져오거나 변경하는 것은 곧, 환경 레코드의 프로퍼티를 가져오거나 변경하는 것이다
    2. 외부 렉시컬 환경에 대한 참조

<br>

```javascript
let global = "global";          // 전역 렉시컬 환경 

// if문 코드블록 렉시컬 환경
// 외부 렉시컬 환경에 대한 참조 -> 외부 렉시컬 환경 = 전역 렉시컬 환경 
if(true){                       
    let inner = "inner";        
}

function temp(){
    let test = "test";
    console.log(test + "/" + global);
}

temp();

// function 코드블록 렉시컬 환경 : function의 렉시컬 환경은 함수가 호출된 시점에 생성된다
// 외부 렉시컬 환경에 대한 참조 -> 외부 렉시컬 환경 = 전역 렉시컬 환경 
// 함수 내부에 global이라는 변수가 없으므로, 외부 렉시컬 환경에서 global을 찾아 사용한다 
```

- 코드 블록마다 내부 렉시컬 환경이 생성된다
- 내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 갖는다
- [참고] https://bit.ly/3qEeyJq

<br>

### 🚀 전역 렉시컬 환경(Global Lexical Environment)
- 스크립트 전체와 관련된 렉시컬 환경을 말하며, 최상위 렉시컬 환경이다
- 최상위 렉시컬 환경이므로, 전역 렉시컬 환경은 외부 참조를 갖지 않는다

<br>

### 🚀 변수의 렉시컬 환경
- 스크립트가 실행되면, 스크립트 내에서 선언된 변수 전체가 렉시컬 환경에 올라간다
- 변수가 렉시컬 환경에 올라갈 때에는, 변수의 선언 방식에 따라 초기화가 된 상태로 렉시컬 환경에 올라가는지 결정된다
    - `var` : 선언과 초기화를 동시에
    - `let`, `const` : 선언과 초기화의 단계가 별도로 진행
- 변수는 선언 방식에 따라 렉시컬 환경에서의 상태가 다르므로, 특수 내부 상태를 갖는다
- 선언만 된 변수의 특수 내부 상태(Special Internal State)는 `uninitialized`이다. 
    - `uninitialized`는 변수가 선언만 되었고 초기화되지 않았다는 의미인 것 같다
    - 실제 let이나 const를 사용해 초기화한 코드를 만나야 초기화되며 `uninitialized`가 풀린다

<br>

### 🚀 함수의 렉시컬 환경
```javascript
// 1. 함수 선언식 (function declarations)
function add(x, y) {
  return x + y;
}
// 2. 함수 표현식 (function expressions)
const func = function(x, y) {
  return x + y;
}
// 3. 화살표 함수 (arrow function)
const add = (x, y) => x + y;
```
- 함수 선언식(function declarations)으로 선언한 함수는 일반 변수와는 달리 바로 초기화된다
- 함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다
- 함수 선언부의 위치와 상관없이 선언 전에도 함수를 사용할 수 있는 이유이다

<br>

### 🚀 렉시컬 환경은 명세서에만 존재한다
- 자바스크립트가 어떻게 동작하는지 설명하기위한 이론상의 객체이다
- 그렇기때문에 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능하다

<br>

### 🚀 내부, 외부 렉시컬 환경
- 함수를 호출해 실행하면 해당 코드 블럭에 대한 렉시컬 환경이 만들어진다
- 이 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장된다
- 함수가 호출 중인 동안엔 호출 중인 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경을 갖게 된다
    - 코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다 
    - 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다
    - 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복된다

<br>
<br>

## 🔥 [결론] Lexical 스코프 방식을 사용하는 자바스크립트의 Lexical 환경
- Lexical 스코프 방식은 상위 스코프를 결정하는 방법이다
- 자바스크립트에서는 Lexical 스코프 방식을 따라 상위 스코프를 결정한다
- 상위 스코프와의 관계에 대한 정보 뿐만 아니라 다양한 환경 레코드에 대한 정보를 갖는 객체가 바로 Lexical 환경이다
- Lexical 환경은 `환경 레코드` 와 `외부 렉시컬 환경에 대한 참조` 로 구성된다
    - `환경 레코드`는 모든 지역 변수를 프로퍼티로 저장하는 객체의 형태를 갖는다
    - `외부 렉시컬 환경에 대한 참조` 는 상위 스코프에 대한 참조를 의미한다




<hr>

### [참고] 
 
https://eyabc.github.io/Doc/dev/core-javascript/%EB%A0%89%EC%8B%9C%EC%BB%AC%20%ED%99%98%EA%B2%BD.html#%EB%82%B4%EB%B6%80%EC%99%80-%EC%99%B8%EB%B6%80-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD
https://ko.javascript.info/closure#ref-481 `추천👍` <br>
https://godtaehee.tistory.com/4 `추천👍` 


